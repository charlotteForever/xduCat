{"ast":null,"code":"import { nextTick } from 'vue';\nimport throttle from 'lodash/throttle';\nimport { entries } from '../utils/util';\nimport { getScrollContainer, getOffsetTopDistance } from '../utils/dom';\nimport throwError from '../utils/error';\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\n\nconst EMPTY_OBJ = process.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};\nconst EMPTY_ARR = process.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];\n\nconst isFunction = val => typeof val === 'function';\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\nconst SCOPE = \"ElInfiniteScroll\";\nconst CHECK_INTERVAL = 50;\nconst DEFAULT_DELAY = 200;\nconst DEFAULT_DISTANCE = 0;\nconst attributes = {\n  delay: {\n    type: Number,\n    default: DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    default: DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  immediate: {\n    type: Boolean,\n    default: true\n  }\n};\n\nconst getScrollOptions = (el, instance) => {\n  return entries(attributes).reduce((acm, [name, option]) => {\n    var _a, _b;\n\n    const {\n      type,\n      default: defaultValue\n    } = option;\n    const attrVal = el.getAttribute(`infinite-scroll-${name}`);\n    let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\n\nconst destroyObserver = el => {\n  const {\n    observer\n  } = el[SCOPE];\n\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\n\nconst handleScroll = (el, cb) => {\n  const {\n    container,\n    containerEl,\n    instance,\n    observer,\n    lastScrollTop\n  } = el[SCOPE];\n  const {\n    disabled,\n    distance\n  } = getScrollOptions(el, instance);\n  const {\n    clientHeight,\n    scrollHeight,\n    scrollTop\n  } = containerEl;\n  const delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0) return;\n  let shouldTrigger = false;\n\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    const {\n      clientTop,\n      scrollHeight: height\n    } = el;\n    const offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\n\nfunction checkFull(el, cb) {\n  const {\n    containerEl,\n    instance\n  } = el[SCOPE];\n  const {\n    disabled\n  } = getScrollOptions(el, instance);\n  if (disabled) return;\n\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\n\nconst InfiniteScroll = {\n  mounted(el, binding) {\n    return __async(this, null, function* () {\n      const {\n        instance,\n        value: cb\n      } = binding;\n\n      if (!isFunction(cb)) {\n        throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n      }\n\n      yield nextTick();\n      const {\n        delay,\n        immediate\n      } = getScrollOptions(el, instance);\n      const container = getScrollContainer(el, true);\n      const containerEl = container === window ? document.documentElement : container;\n      const onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n      if (!container) return;\n      el[SCOPE] = {\n        instance,\n        container,\n        containerEl,\n        delay,\n        cb,\n        onScroll,\n        lastScrollTop: containerEl.scrollTop\n      };\n\n      if (immediate) {\n        const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n        el[SCOPE].observer = observer;\n        observer.observe(el, {\n          childList: true,\n          subtree: true\n        });\n        checkFull(el, cb);\n      }\n\n      container.addEventListener(\"scroll\", onScroll);\n    });\n  },\n\n  unmounted(el) {\n    const {\n      container,\n      onScroll\n    } = el[SCOPE];\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n\n};\nconst _InfiniteScroll = InfiniteScroll;\n\n_InfiniteScroll.install = app => {\n  app.directive(\"InfiniteScroll\", _InfiniteScroll);\n};\n\nexport default _InfiniteScroll;","map":{"version":3,"sources":["D:/A-大三下/web开发/xducat/xducat-client/node_modules/element-plus/es/el-infinite-scroll/index.js"],"names":["nextTick","throttle","entries","getScrollContainer","getOffsetTopDistance","throwError","EMPTY_OBJ","process","env","NODE_ENV","Object","freeze","EMPTY_ARR","isFunction","val","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","throw","x","done","then","apply","SCOPE","CHECK_INTERVAL","DEFAULT_DELAY","DEFAULT_DISTANCE","attributes","delay","type","Number","default","distance","disabled","Boolean","immediate","getScrollOptions","el","instance","reduce","acm","name","option","_a","_b","defaultValue","attrVal","getAttribute","isNaN","destroyObserver","observer","disconnect","handleScroll","cb","container","containerEl","lastScrollTop","clientHeight","scrollHeight","scrollTop","delta","shouldTrigger","clientTop","height","offsetTop","call","checkFull","InfiniteScroll","mounted","binding","window","document","documentElement","onScroll","bind","MutationObserver","observe","childList","subtree","addEventListener","unmounted","removeEventListener","_InfiniteScroll","install","app","directive"],"mappings":"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","sourcesContent":["import { nextTick } from 'vue';\nimport throttle from 'lodash/throttle';\nimport { entries } from '../utils/util';\nimport { getScrollContainer, getOffsetTopDistance } from '../utils/dom';\nimport throwError from '../utils/error';\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\n    ? Object.freeze({})\n    : {};\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\nconst isFunction = (val) => typeof val === 'function';\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst SCOPE = \"ElInfiniteScroll\";\nconst CHECK_INTERVAL = 50;\nconst DEFAULT_DELAY = 200;\nconst DEFAULT_DISTANCE = 0;\nconst attributes = {\n  delay: {\n    type: Number,\n    default: DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    default: DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  immediate: {\n    type: Boolean,\n    default: true\n  }\n};\nconst getScrollOptions = (el, instance) => {\n  return entries(attributes).reduce((acm, [name, option]) => {\n    var _a, _b;\n    const { type, default: defaultValue } = option;\n    const attrVal = el.getAttribute(`infinite-scroll-${name}`);\n    let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\nconst destroyObserver = (el) => {\n  const { observer } = el[SCOPE];\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\nconst handleScroll = (el, cb) => {\n  const {\n    container,\n    containerEl,\n    instance,\n    observer,\n    lastScrollTop\n  } = el[SCOPE];\n  const { disabled, distance } = getScrollOptions(el, instance);\n  const { clientHeight, scrollHeight, scrollTop } = containerEl;\n  const delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0)\n    return;\n  let shouldTrigger = false;\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    const { clientTop, scrollHeight: height } = el;\n    const offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\nfunction checkFull(el, cb) {\n  const { containerEl, instance } = el[SCOPE];\n  const { disabled } = getScrollOptions(el, instance);\n  if (disabled)\n    return;\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\nconst InfiniteScroll = {\n  mounted(el, binding) {\n    return __async(this, null, function* () {\n      const { instance, value: cb } = binding;\n      if (!isFunction(cb)) {\n        throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n      }\n      yield nextTick();\n      const { delay, immediate } = getScrollOptions(el, instance);\n      const container = getScrollContainer(el, true);\n      const containerEl = container === window ? document.documentElement : container;\n      const onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n      if (!container)\n        return;\n      el[SCOPE] = {\n        instance,\n        container,\n        containerEl,\n        delay,\n        cb,\n        onScroll,\n        lastScrollTop: containerEl.scrollTop\n      };\n      if (immediate) {\n        const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n        el[SCOPE].observer = observer;\n        observer.observe(el, { childList: true, subtree: true });\n        checkFull(el, cb);\n      }\n      container.addEventListener(\"scroll\", onScroll);\n    });\n  },\n  unmounted(el) {\n    const { container, onScroll } = el[SCOPE];\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n};\n\nconst _InfiniteScroll = InfiniteScroll;\n_InfiniteScroll.install = (app) => {\n  app.directive(\"InfiniteScroll\", _InfiniteScroll);\n};\n\nexport default _InfiniteScroll;\n"]},"metadata":{},"sourceType":"module"}