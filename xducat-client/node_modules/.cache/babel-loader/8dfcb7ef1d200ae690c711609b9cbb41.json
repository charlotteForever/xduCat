{"ast":null,"code":"import { isNumber, $, isString } from '../utils/util';\nimport throwError from '../utils/error';\nimport { defineComponent, ref, reactive, computed, watch, onMounted, onBeforeUnmount, h, withModifiers, getCurrentInstance, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport memo from 'lodash/memoize';\nimport isServer from '../utils/isServer';\nimport { cAF, rAF } from '../utils/raf';\nimport { on, off } from '../utils/dom';\nimport getScrollBarWidth from '../utils/scrollbar-width';\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\n\nconst EMPTY_OBJ = process.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};\nconst EMPTY_ARR = process.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];\n\nconst NOOP = () => {};\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\n\nconst isFunction = val => typeof val === 'function';\n\nconst isObject = val => val !== null && typeof val === 'object';\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst DefaultListProps = {\n  cache: {\n    type: Number,\n    default: 2\n  },\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  data: {\n    type: [Array],\n    default: () => []\n  },\n  direction: {\n    type: String,\n    default: \"ltr\",\n    validator: val => {\n      return val === LTR || val === RTL;\n    }\n  },\n  estimatedItemSize: {\n    type: [Number]\n  },\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  layout: {\n    type: String,\n    default: VERTICAL\n  },\n  initScrollOffset: {\n    type: Number,\n    default: 0\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  total: {\n    type: Number,\n    required: true\n  },\n  itemSize: {\n    type: [Number, Function],\n    required: true\n  },\n  style: {\n    type: [Object, String, Array],\n    default: () => ({})\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  }\n};\nconst DefaultGridProps = {\n  className: DefaultListProps.className,\n  columnCache: DefaultListProps.cache,\n  columnWidth: DefaultListProps.itemSize,\n  containerElement: DefaultListProps.containerElement,\n  data: DefaultListProps.data,\n  direction: DefaultListProps.direction,\n  estimatedColumnWidth: DefaultListProps.estimatedItemSize,\n  estimatedRowHeight: DefaultListProps.estimatedItemSize,\n  height: __spreadProps(__spreadValues({}, DefaultListProps.height), {\n    validator: val => isNumber(val)\n  }),\n  initScrollLeft: DefaultListProps.initScrollOffset,\n  initScrollTop: DefaultListProps.initScrollOffset,\n  innerElement: DefaultListProps.innerElement,\n  rowCache: DefaultListProps.cache,\n  rowHeight: DefaultListProps.itemSize,\n  style: DefaultListProps.style,\n  useIsScrolling: DefaultListProps.useIsScrolling,\n  width: __spreadProps(__spreadValues({}, DefaultListProps.width), {\n    validator: val => {\n      return isNumber(val);\n    }\n  }),\n  totalColumn: DefaultListProps.total,\n  totalRow: DefaultListProps.total\n};\nconst DefaultScrollBarProps = {\n  layout: DefaultListProps.layout,\n  total: Number,\n  ratio: Number,\n  clientSize: Number,\n  scrollFrom: Number,\n  visible: Boolean\n};\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\n\nconst isHorizontal = dir => dir === LTR || dir === RTL || dir === HORIZONTAL;\n\nconst isRTL = dir => dir === RTL;\n\nlet cachedRTLResult = null;\n\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nfunction renderThumbStyle({\n  move,\n  size,\n  bar\n}, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n\n  return style;\n}\n\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\n\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let offset = 0;\n\n  const hasReachedEdge = offset2 => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n\n  const onWheel = e => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset)) return;\n    offset += newOffset;\n\n    if (!isFF) {\n      e.preventDefault();\n    }\n\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nconst BAR_MAP = {\n  vertical: {\n    offset: \"offsetHeight\",\n    scroll: \"scrollTop\",\n    scrollSize: \"scrollHeight\",\n    size: \"height\",\n    key: \"vertical\",\n    axis: \"Y\",\n    client: \"clientY\",\n    direction: \"top\"\n  },\n  horizontal: {\n    offset: \"offsetWidth\",\n    scroll: \"scrollLeft\",\n    scrollSize: \"scrollWidth\",\n    size: \"width\",\n    key: \"horizontal\",\n    axis: \"X\",\n    client: \"clientX\",\n    direction: \"left\"\n  }\n};\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: DefaultScrollBarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n\n  setup(props, {\n    emit\n  }) {\n    const trackRef = ref(null);\n    const thumbRef = ref(null);\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackStyle = computed(() => ({\n      display: props.visible ? null : \"none\",\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? \"100%\" : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : \"100%\",\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      if (props.ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (props.ratio >= 50) {\n        return props.ratio * props.clientSize / 100;\n      }\n\n      const SCROLLBAR_MAX_SIZE = props.clientSize / 3;\n      return Math.floor(Math.min(Math.max(props.ratio * props.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - 4));\n\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = thumbRef.value;\n      onselectstartStore = document.onselectstart;\n\n      document.onselectstart = () => false;\n\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = thumbRef.value;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n\n    const onScrollbarTouchStart = e => e.preventDefault();\n\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * props.clientSize / (props.clientSize / totalSteps.value));\n    });\n    onMounted(() => {\n      if (isServer) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(NOOP, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, null));\n    };\n  }\n\n});\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {\n    if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const scrollbarRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = $(states);\n\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getStartIndexForOffset(props, scrollOffset, $(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, $(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, $(dynamicSizeCache)));\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"hidden\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, __spreadValues$1({\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style)]);\n      const innerStyle = computed(() => {\n        const size = $(estimatedTotalSize);\n        const horizontal = $(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = $(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n\n        const _states = $(states);\n\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = $(states);\n\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const onScroll = e => {\n        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n\n        if (offset === $(states).scrollOffset) {\n          return;\n        }\n\n        states.value = __spreadProps$1(__spreadValues$1({}, $(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir($(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = $(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, $(dynamicSizeCache)));\n      };\n\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, $(dynamicSizeCache));\n          const size = getItemSize(props, idx, $(dynamicSizeCache));\n          const horizontal = $(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n\n        return style;\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = $(windowRef);\n\n        if (isNumber(initScrollOffset) && windowElement !== null) {\n          if ($(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = $(states);\n\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n\n    render(ctx) {\n      var _a;\n\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [listContainer, scrollbar]);\n    }\n\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({\n    itemSize\n  }, index) => index * itemSize,\n  getItemSize: ({\n    itemSize\n  }) => itemSize,\n  getEstimatedTotalSize: ({\n    total,\n    itemSize\n  }) => itemSize * total,\n  getOffset: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n\n    if (process.env.ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: ({\n    total,\n    itemSize\n  }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n\n  initCache() {\n    return void 0;\n  },\n\n  clearCache: true,\n\n  validateProps() {}\n\n});\nconst SCOPE = \"ElDynamicSizeList\";\n\nconst getItemFromCache = (props, index, listCache) => {\n  const {\n    itemSize\n  } = props;\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    listCache.lastVisitedIndex = index;\n  }\n\n  return items[index];\n};\n\nconst findItem = (props, listCache, offset) => {\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\n\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n\n  return Math.max(0, low - 1);\n};\n\nconst es = (props, listCache, index, offset) => {\n  const {\n    total\n  } = props;\n  let exponent = 1;\n\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\n\nconst getEstimatedTotalSize = ({\n  total\n}, {\n  items,\n  estimatedItemSize,\n  lastVisitedIndex\n}) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, {\n    items\n  }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const {\n      height,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const {\n      height,\n      total,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n\n    return stopIndex;\n  },\n\n  initCache({\n    estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      instance.exposed.getItemStyleCache(-1);\n\n      if (forceUpdate) {\n        instance.proxy.$forceUpdate();\n      }\n    };\n\n    return cache;\n  },\n\n  clearCache: false,\n  validateProps: ({\n    itemSize\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {\n    if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = $(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, $(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, $(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = $(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, $(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, $(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, $(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, $(cache)));\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"auto\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, __spreadValues$2({\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style)]);\n      const innerStyle = computed(() => {\n        const width = `${$(estimatedTotalWidth)}px`;\n        const height = `${$(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = $(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = $(states);\n\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n\n        let _scrollLeft = scrollLeft;\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n\n      const scrollTo = ({\n        scrollLeft,\n        scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n\n        const _states = $(states);\n\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = $(states);\n\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n\n        const _cache = $(cache);\n\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, $(cache));\n\n          const _cache = $(cache);\n\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = $(windowRef);\n\n        if (windowElement !== null) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = $(states);\n\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      const api = {\n        windowStyle,\n        windowRef,\n        columnsToRender,\n        innerRef,\n        innerStyle,\n        states,\n        rowsToRender,\n        getItemStyle,\n        onScroll,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n\n    render(ctx) {\n      var _a;\n\n      const {\n        $slots,\n        className,\n        containerElement,\n        columnsToRender,\n        data,\n        getItemStyle,\n        innerElement,\n        innerStyle,\n        rowsToRender,\n        onScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        totalColumn,\n        totalRow\n      } = ctx;\n      const [columnStart, columnEnd] = columnsToRender;\n      const [rowStart, rowEnd] = rowsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n\n      if (totalRow > 0 && totalColumn > 0) {\n        for (let row = rowStart; row <= rowEnd; row++) {\n          for (let column = columnStart; column <= columnEnd; column++) {\n            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n              columnIndex: column,\n              data,\n              key: column,\n              isScrolling: useIsScrolling ? states.isScrolling : void 0,\n              style: getItemStyle(row, column),\n              rowIndex: row\n            }));\n          }\n        }\n      }\n\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      return h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        ref: \"windowRef\"\n      }, !isString(Container) ? {\n        default: () => InnerNode\n      } : InnerNode);\n    }\n\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({\n    columnWidth\n  }, index) => [columnWidth, index * columnWidth],\n  getRowPosition: ({\n    rowHeight\n  }, index) => [rowHeight, index * rowHeight],\n  getEstimatedTotalHeight: ({\n    totalRow,\n    rowHeight\n  }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({\n    totalColumn,\n    columnWidth\n  }) => columnWidth * totalColumn,\n  getColumnOffset: ({\n    totalColumn,\n    columnWidth,\n    width\n  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getRowOffset: ({\n    rowHeight,\n    height,\n    totalRow\n  }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: ({\n    columnWidth,\n    totalColumn\n  }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({\n    columnWidth,\n    totalColumn,\n    width\n  }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({\n    rowHeight,\n    totalRow\n  }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({\n    rowHeight,\n    totalRow,\n    height\n  }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nconst {\n  max,\n  min,\n  floor\n} = Math;\nconst SCOPE$2 = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\n\nconst getItemFromCache$1 = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n\n  if (index > lastVisited) {\n    let offset = 0;\n\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n\n  return cachedItems[index];\n};\n\nconst bs$1 = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, gridCache, type).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  return max(0, low - 1);\n};\n\nconst es$1 = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n\n  while (idx < total && getItemFromCache$1(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n\n  return bs$1(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\n\nconst findItem$1 = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs$1(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n\n  return es$1(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\n\nconst getEstimatedTotalHeight = ({\n  totalRow\n}, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\n\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\n\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]];\n  const item = getItemFromCache$1(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\n\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem$1(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache$1(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, startIndex, cache, \"column\").size;\n    }\n\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem$1(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const {\n      totalRow,\n      height\n    } = props;\n    const item = getItemFromCache$1(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, cache, \"row\").size;\n    }\n\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid$1 as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid, FixedSizeList };","map":{"version":3,"sources":["D:/A-/web/xducat/xducat-client/node_modules/element-plus/es/el-virtual-list/index.js"],"names":["isNumber","$","isString","throwError","defineComponent","ref","reactive","computed","watch","onMounted","onBeforeUnmount","h","withModifiers","getCurrentInstance","onUpdated","resolveDynamicComponent","nextTick","memo","isServer","cAF","rAF","on","off","getScrollBarWidth","EMPTY_OBJ","process","env","NODE_ENV","Object","freeze","EMPTY_ARR","NOOP","hasOwnProperty","prototype","hasOwn","val","key","call","isFunction","isObject","__defProp","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","value","enumerable","configurable","writable","__spreadValues","a","b","prop","__spreadProps","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","ITEM_RENDER_EVT","SCROLL_EVT","FORWARD","BACKWARD","AUTO_ALIGNMENT","SMART_ALIGNMENT","START_ALIGNMENT","CENTERED_ALIGNMENT","END_ALIGNMENT","HORIZONTAL","VERTICAL","LTR","RTL","RTL_OFFSET_NAG","RTL_OFFSET_POS_ASC","RTL_OFFSET_POS_DESC","DefaultListProps","cache","type","Number","default","className","String","containerElement","data","Array","direction","validator","estimatedItemSize","height","required","layout","initScrollOffset","innerElement","total","itemSize","Function","style","useIsScrolling","Boolean","width","DefaultGridProps","columnCache","columnWidth","estimatedColumnWidth","estimatedRowHeight","initScrollLeft","initScrollTop","rowCache","rowHeight","totalColumn","totalRow","DefaultScrollBarProps","ratio","clientSize","scrollFrom","visible","ScrollbarDirKey","SCROLLBAR_MIN_SIZE","getScrollDir","prev","cur","isHorizontal","dir","isRTL","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","overflow","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","renderThumbStyle","move","size","bar","translate","axis","transform","msTransform","webkitTransform","isFF","navigator","test","userAgent","LayoutKeys","useWheel","atEndEdge","atStartEdge","onWheelDelta","frameHandle","offset","hasReachedEdge","offset2","edgeReached","onWheel","e","newOffset","preventDefault","BAR_MAP","vertical","scroll","scrollSize","client","horizontal","ScrollBar","name","props","emits","setup","emit","trackRef","thumbRef","onselectstartStore","state","isDragging","traveled","trackStyle","display","position","right","bottom","borderRadius","thumbSize","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","thumbStyle","isFinite","thumb","totalSteps","attachEvents","window","onMouseMove","onMouseUp","thumbEl","onselectstart","detachEvents","onThumbMouseDown","stopImmediatePropagation","ctrlKey","includes","button","currentTarget","getBoundingClientRect","prevPage","thumbClickPosition","distance","onScrollbarTouchStart","v","ceil","role","class","onMousedown","__defProp$1","__defProps$1","__getOwnPropDescs$1","__getOwnPropSymbols$1","__hasOwnProp$1","__propIsEnum$1","__defNormalProp$1","__spreadValues$1","__spreadProps$1","createList","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","expose","instance","dynamicSizeCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","updateRequested","isScrollbarDragging","itemsToRender","startIndex","stopIndex","cacheBackward","cacheForward","estimatedTotalSize","_isHorizontal","windowStyle","WebkitOverflowScrolling","willChange","pointerEvents","_a","_b","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","clientHeight","scrollHeight","scrollTop","_states","resetIsScrolling","scrollHorizontally","clientWidth","scrollWidth","onScroll","onScrollbarScroll","distanceToGo","getItemStyleCache","_","__","___","scrollToItem","idx","alignment","getItemStyle","itemStyleCache","isRtl","offsetHorizontal","left","top","windowElement","api","render","ctx","$slots","start","end","Container","Inner","children","i","push","index","InnerNode","scrollbar","listContainer","FixedSizeList","ENV","lastItemOffset","maxOffset","minOffset","middleOffset","round","numVisibleItems","SCOPE","getItemFromCache","listCache","items","lastVisitedIndex","item","findItem","lastVisitedOffset","bs","es","low","high","mid","currentOffset","exponent","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","clearCacheAfterIndex","forceUpdate","exposed","proxy","$forceUpdate","__defProp$2","__defProps$2","__getOwnPropDescs$2","__getOwnPropSymbols$2","__hasOwnProp$2","__propIsEnum$2","__defNormalProp$2","__spreadValues$2","__spreadProps$2","createGrid","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","xAxisScrollDir","yAxisScrollDir","columnsToRender","rowsToRender","estimatedTotalHeight","estimatedTotalWidth","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","_scrollLeft","rowIndex","columnIdx","scrollBarWidth","_cache","estimatedHeight","estimatedWidth","columnIndex","rtl","columnStart","columnEnd","rowStart","rowEnd","row","column","SCOPE$1","FixedSizeGrid","lastColumnOffset","align","lastRowOffset","visibleColumnsCount","numVisibleRows","SCOPE$2","ACCESS_SIZER_KEY_MAP","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache$1","gridCache","cachedItems","sizer","lastVisited","bs$1","es$1","findItem$1","lastVisitedItemOffset","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","estimatedSizeAssociates","estimatedSize","FixedSizeGrid$1","DynamicSizeGrid"],"mappings":"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","sourcesContent":["import { isNumber, $, isString } from '../utils/util';\nimport throwError from '../utils/error';\nimport { defineComponent, ref, reactive, computed, watch, onMounted, onBeforeUnmount, h, withModifiers, getCurrentInstance, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport memo from 'lodash/memoize';\nimport isServer from '../utils/isServer';\nimport { cAF, rAF } from '../utils/raf';\nimport { on, off } from '../utils/dom';\nimport getScrollBarWidth from '../utils/scrollbar-width';\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\n    ? Object.freeze({})\n    : {};\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\nconst NOOP = () => { };\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isFunction = (val) => typeof val === 'function';\nconst isObject = (val) => val !== null && typeof val === 'object';\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst DefaultListProps = {\n  cache: {\n    type: Number,\n    default: 2\n  },\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  data: {\n    type: [Array],\n    default: () => []\n  },\n  direction: {\n    type: String,\n    default: \"ltr\",\n    validator: (val) => {\n      return val === LTR || val === RTL;\n    }\n  },\n  estimatedItemSize: {\n    type: [Number]\n  },\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  layout: {\n    type: String,\n    default: VERTICAL\n  },\n  initScrollOffset: {\n    type: Number,\n    default: 0\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  total: {\n    type: Number,\n    required: true\n  },\n  itemSize: {\n    type: [Number, Function],\n    required: true\n  },\n  style: {\n    type: [Object, String, Array],\n    default: () => ({})\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  }\n};\nconst DefaultGridProps = {\n  className: DefaultListProps.className,\n  columnCache: DefaultListProps.cache,\n  columnWidth: DefaultListProps.itemSize,\n  containerElement: DefaultListProps.containerElement,\n  data: DefaultListProps.data,\n  direction: DefaultListProps.direction,\n  estimatedColumnWidth: DefaultListProps.estimatedItemSize,\n  estimatedRowHeight: DefaultListProps.estimatedItemSize,\n  height: __spreadProps(__spreadValues({}, DefaultListProps.height), {\n    validator: (val) => isNumber(val)\n  }),\n  initScrollLeft: DefaultListProps.initScrollOffset,\n  initScrollTop: DefaultListProps.initScrollOffset,\n  innerElement: DefaultListProps.innerElement,\n  rowCache: DefaultListProps.cache,\n  rowHeight: DefaultListProps.itemSize,\n  style: DefaultListProps.style,\n  useIsScrolling: DefaultListProps.useIsScrolling,\n  width: __spreadProps(__spreadValues({}, DefaultListProps.width), {\n    validator: (val) => {\n      return isNumber(val);\n    }\n  }),\n  totalColumn: DefaultListProps.total,\n  totalRow: DefaultListProps.total\n};\nconst DefaultScrollBarProps = {\n  layout: DefaultListProps.layout,\n  total: Number,\n  ratio: Number,\n  clientSize: Number,\n  scrollFrom: Number,\n  visible: Boolean\n};\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\nconst isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;\nconst isRTL = (dir) => dir === RTL;\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n  return cachedRTLResult;\n}\nfunction renderThumbStyle({ move, size, bar }, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n  return style;\n}\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\n\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let offset = 0;\n  const hasReachedEdge = (offset2) => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n  const onWheel = (e) => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))\n      return;\n    offset += newOffset;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nconst BAR_MAP = {\n  vertical: {\n    offset: \"offsetHeight\",\n    scroll: \"scrollTop\",\n    scrollSize: \"scrollHeight\",\n    size: \"height\",\n    key: \"vertical\",\n    axis: \"Y\",\n    client: \"clientY\",\n    direction: \"top\"\n  },\n  horizontal: {\n    offset: \"offsetWidth\",\n    scroll: \"scrollLeft\",\n    scrollSize: \"scrollWidth\",\n    size: \"width\",\n    key: \"horizontal\",\n    axis: \"X\",\n    client: \"clientX\",\n    direction: \"left\"\n  }\n};\n\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: DefaultScrollBarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, { emit }) {\n    const trackRef = ref(null);\n    const thumbRef = ref(null);\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackStyle = computed(() => ({\n      display: props.visible ? null : \"none\",\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? \"100%\" : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : \"100%\",\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      if (props.ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (props.ratio >= 50) {\n        return props.ratio * props.clientSize / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = props.clientSize / 3;\n      return Math.floor(Math.min(Math.max(props.ratio * props.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - 4));\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = thumbRef.value;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = thumbRef.value;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = (e) => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = (e) => {\n      const { isDragging } = state;\n      if (!isDragging)\n        return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage)\n        return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const onScrollbarTouchStart = (e) => e.preventDefault();\n    watch(() => props.scrollFrom, (v) => {\n      if (state.isDragging)\n        return;\n      state.traveled = Math.ceil(v * props.clientSize / (props.clientSize / totalSteps.value));\n    });\n    onMounted(() => {\n      if (isServer)\n        return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(NOOP, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, null));\n    };\n  }\n});\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const scrollbarRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const { total, cache } = props;\n        const { isScrolling, scrollDir, scrollOffset } = $(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, $(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, $(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, $(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        __spreadValues$1({\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, props.style)\n      ]);\n      const innerStyle = computed(() => {\n        const size = $(estimatedTotalSize);\n        const horizontal = $(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, (offset) => {\n        var _a, _b;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const { total } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const { scrollDir, scrollOffset, updateRequested } = $(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = (e) => {\n        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = (e) => {\n        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const { direction } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft;\n              break;\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n            }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = (e) => {\n        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = (offset) => {\n        offset = Math.max(offset, 0);\n        if (offset === $(states).scrollOffset) {\n          return;\n        }\n        states.value = __spreadProps$1(__spreadValues$1({}, $(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir($(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const { scrollOffset } = $(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, $(dynamicSizeCache)));\n      };\n      const getItemStyle = (idx) => {\n        const { direction, itemSize, layout } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, $(dynamicSizeCache));\n          const size = getItemSize(props, idx, $(dynamicSizeCache));\n          const horizontal = $(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollOffset } = props;\n        const windowElement = $(windowRef);\n        if (isNumber(initScrollOffset) && windowElement !== null) {\n          if ($(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction, layout } = props;\n        const { scrollOffset, updateRequested } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\": {\n                  windowElement.scrollLeft = -scrollOffset;\n                  break;\n                }\n                case \"positive-ascending\": {\n                  windowElement.scrollLeft = scrollOffset;\n                  break;\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                  break;\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [\n        listContainer,\n        scrollbar\n      ]);\n    }\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({ itemSize }, index) => index * itemSize,\n  getItemSize: ({ itemSize }) => itemSize,\n  getEstimatedTotalSize: ({ total, itemSize }) => itemSize * total,\n  getOffset: ({ height, total, itemSize, layout, width }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n    if (process.env.ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0;\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset;\n        } else {\n          return middleOffset;\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: ({ total, itemSize }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({ height, total, itemSize, layout, width }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps() {\n  }\n});\n\nconst SCOPE = \"ElDynamicSizeList\";\nconst getItemFromCache = (props, index, listCache) => {\n  const { itemSize } = props;\n  const { items, lastVisitedIndex } = listCache;\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nconst findItem = (props, listCache, offset) => {\n  const { items, lastVisitedIndex } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nconst es = (props, listCache, index, offset) => {\n  const { total } = props;\n  let exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nconst getEstimatedTotalSize = ({ total }, { items, estimatedItemSize, lastVisitedIndex }) => {\n  let totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, { items }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      instance.exposed.getItemStyleCache(-1);\n      if (forceUpdate) {\n        instance.proxy.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props;\n        const { isScrolling, xAxisScrollDir, scrollLeft } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, $(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, $(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props;\n        const { isScrolling, yAxisScrollDir, scrollTop } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, $(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, $(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, $(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, $(cache)));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"auto\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        __spreadValues$2({\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, props.style)\n      ]);\n      const innerStyle = computed(() => {\n        const width = `${$(estimatedTotalWidth)}px`;\n        const height = `${$(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n        const { scrollLeft, scrollTop, updateRequested, xAxisScrollDir, yAxisScrollDir } = $(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n      const onScroll = (e) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = ({\n        scrollLeft,\n        scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = $(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = $(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n        const _cache = $(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const { columnWidth, direction, rowHeight } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, $(cache));\n          const _cache = $(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollLeft, initScrollTop } = props;\n        const windowElement = $(windowRef);\n        if (windowElement !== null) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction } = props;\n        const { scrollLeft, scrollTop, updateRequested } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft;\n                break;\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft;\n                break;\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement;\n                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      const api = {\n        windowStyle,\n        windowRef,\n        columnsToRender,\n        innerRef,\n        innerStyle,\n        states,\n        rowsToRender,\n        getItemStyle,\n        onScroll,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        containerElement,\n        columnsToRender,\n        data,\n        getItemStyle,\n        innerElement,\n        innerStyle,\n        rowsToRender,\n        onScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        totalColumn,\n        totalRow\n      } = ctx;\n      const [columnStart, columnEnd] = columnsToRender;\n      const [rowStart, rowEnd] = rowsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (totalRow > 0 && totalColumn > 0) {\n        for (let row = rowStart; row <= rowEnd; row++) {\n          for (let column = columnStart; column <= columnEnd; column++) {\n            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n              columnIndex: column,\n              data,\n              key: column,\n              isScrolling: useIsScrolling ? states.isScrolling : void 0,\n              style: getItemStyle(row, column),\n              rowIndex: row\n            }));\n          }\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      return h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        ref: \"windowRef\"\n      }, !isString(Container) ? { default: () => InnerNode } : InnerNode);\n    }\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth,\n    index * columnWidth\n  ],\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight,\n    index * rowHeight\n  ],\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,\n  getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nconst { max, min, floor } = Math;\nconst SCOPE$2 = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache$1 = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs$1 = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es$1 = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache$1(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs$1(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem$1 = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs$1(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es$1(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({ totalRow }, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [\n    size,\n    estimatedSizeAssociates\n  ] = [\n    type === \"row\" ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type]\n  ];\n  const item = getItemFromCache$1(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset;\n    }\n    case END_ALIGNMENT: {\n      return minOffset;\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n};\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem$1(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache$1(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem$1(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props;\n    const item = getItemFromCache$1(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nexport { FixedSizeGrid$1 as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid, FixedSizeList };\n"]},"metadata":{},"sourceType":"module"}